# -*- python -*-

# -*- coding: latin-1 -*-
#
#       Virtual Fruit / CGALMeshing
#
#       Copyright 2006 - 2016 INRIA - CIRAD - INRA  
#
#       File author(s): Mik Cieslak <mikolaj.cieslak@inria.fr>
#                       Guillaume Cerutti <guillaume.cerutti@inria.fr>
#
#       Distributed under the Cecill-C License.
#       See accompanying file LICENSE.txt or copy at
#           http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html
# 
#       OpenAlea WebSite : http://openalea.gforge.inria.fr
################################################################################

__license__ = "Cecill-C"
__revision__ = " $Id: $ "


import numpy as np
import scipy.ndimage as nd
from scipy.cluster.vq import kmeans, vq

import os

from vplants.tissue_analysis.spatial_image_analysis import SpatialImageAnalysis

from openalea.mesh import PropertyTopomesh
from openalea.mesh.utils.array_tools import array_unique

from time import time


class CGALMesh(object):
    """A class providing operations for creating and updating 3D volumetric meshes of tetrahedra"""

    def __init__(self):
        self.vertices = np.array([]) # mesh vertices
        self.triangles = np.array([]) # surface triangles of each tissue (index to vertices)
        self.tri_subdomains = np.array([]) # tissue id of each triangle        
        self.tetrahedra = np.array([]) # tetrahedra of each tissue (index to vertices)
        self.tetra_subdomains = np.array([]) # tissue id of each tetrahedron
        self.nb_vertices = 0 # number of vertices
        self.nb_triangles = 0 # number of triangles
        self.nb_tetrahedra = 0 # number of tetrahedra
        self.face_index_list = np.array([[0,1,2],[0,1,3],[0,2,3],[1,2,3]])

        self.components = np.array([]) # array of all of tissue ids
        
        self.vertex_positions = {}
        
        self.topo_mesh = PropertyTopomesh(3)
        self.topo_cells = np.array([])
        self.topo_triangles = np.array([])
        self.topo_edges = np.array([])
        self.topo_vertices = np.array([])
        return
        
    def createMesh (self, filename, centre_mesh=False):
        """create a tetrahedral mesh from a CGAL mesh file and set all attributes of the mesh"""

        start_time = time()
        print "--> Reading Mesh"
        self.readCGALfile(filename)
        # centre mesh, if necessary
        if centre_mesh:
          centroid = np.mean(self.vertices,axis=0)
          self.vertices = self.vertices - centroid
        # self.computeCentroids()
        # if not simple:
        #   self.findNeighbours(max_tetras_to_check)
        #   self.computeVolumes()
        #   self.computeTetraFaceAreas()
        self.components = np.unique(self.tri_subdomains)
        print self.vertices.shape[0],"Vertices, ",self.triangles.shape[0],"Triangles, ",self.tetrahedra.shape[0],"Tetrahedra, ",self.components.shape[0]," Components"
        end_time = time()
        print "<-- Reading Mesh             [",end_time-start_time,"s]"
        return
                    
    def readCGALfile (self, filename):
        """function to read CGAL mesh file defining a tetrahedral mesh"""
    
        # read in the mesh file generated by CGAL
        infile = open(filename, 'r')

        # init number of elements
        self.nb_vertices = 0
        self.nb_triangles = 0
        self.nb_tetrahedra = 0
    
        dimension = 0
        index = 0
    
        while True:
            line = infile.readline()
            if (line == ""):
                break
            
            # split line into tokens
            tokens = line.split()

            # first token should provide description of input
            if tokens[0] == "MeshVersionFormatted":
                # ensure version 1
                if int(tokens[1]) != 1:
                    print "Warning: unregonized version of CGAL mesh file! This may not work."
            elif tokens[0] == "Dimension":
                # only 3 dimensions are supported
                if int(tokens[1]) != 3:
                    print "Sorry, only 3D meshes are supported."
                    break
            elif tokens[0] == "Vertices":
                # begin reading vertices
                line = infile.readline()
                tokens = line.split()
                self.nb_vertices = int(tokens[0])
                self.vertices = np.fromfile(infile, dtype=np.float, count=self.nb_vertices*4, sep=" ")
                self.vertices = self.vertices.reshape([self.nb_vertices,4])[:,:-1]                
            elif tokens[0] == "Triangles":
                # begin reading triangles
                line = infile.readline()
                tokens = line.split()
                self.nb_triangles = int(tokens[0])
                self.triangles = np.fromfile(infile, dtype=np.int, count=self.nb_triangles*4, sep=" ")
                self.triangles = self.triangles.reshape([self.nb_triangles,4])
                self.tri_subdomains = self.triangles[:,-1]
                self.triangles = self.triangles[:,:-1] - 1
            elif tokens[0] == "Tetrahedra":
                # begin reading tetrahedra
                line = infile.readline()
                tokens = line.split()
                self.nb_tetrahedra = int(tokens[0])
                tetras = np.fromfile(infile, dtype=np.int, count=self.nb_tetrahedra*5, sep=" ")
                tetras = tetras.reshape([self.nb_tetrahedra,5])
                self.tetrahedra = tetras[:,:-1] - 1
                self.tetra_subdomains = tetras[:,-1]                
            elif tokens[0] == "End":
                break
            else:
                print "Warning: unknown entry, ", line.strip(),  ", in file: ", infile
    
        infile.close()

        return

    def saveCGALfile(self,filename):
        start_time = time()
        print "--> Writing Mesh"
        outfile = open(filename, 'w')
        outfile.write("MeshVersionFormatted 1\n")   
        outfile.write("Dimension 3\n")
        outfile.write("Vertices\n")
        outfile.write(str(self.vertices.shape[0])+"\n")
        for v in self.vertices:
            outfile.write(str(v[0])+" "+str(v[1])+" "+str(v[2])+" 0\n")
        outfile.write("Triangles\n")
        outfile.write(str(self.triangles.shape[0])+"\n")
        for t, tri in enumerate(self.triangles):
            outfile.write(str(tri[0]+1)+" "+str(tri[1]+1)+" "+str(tri[2]+1)+" "+str(self.tri_subdomains[t])+"\n")
        outfile.write("Tetrahedra\n")
        outfile.write(str(self.tetrahedra.shape[0])+"\n")
        for t, tetra in enumerate(self.tetrahedra):
            outfile.write(str(tetra[0]+1)+" "+str(tetra[1]+1)+" "+str(tetra[2]+1)+" "+str(tetra[3]+1)+" "+str(self.tetra_subdomains[t])+"\n")
        outfile.write("End\n")
        outfile.close()
        end_time = time()
        print "<-- Writing Mesh             [",end_time-start_time,"s]"

    def reIndexComponents(self, img):
        """Re-index the uint8 labelled components with uint16 labels based on the original image labelling.
           The labels are affected by clustering the positions of the triangles and affecting the original label of the cluster center.
        """

        start_time = time()
        print "--> Re-Indexing Components"

        new = self
        new.tri_subdomains = np.ones_like(mesh.tri_subdomains)
        new.tetra_subdomains = np.ones_like(mesh.tetra_subdomains)

        self.components = np.unique(self.tri_subdomains)

        
        #self.tri_subdomains[np.where(self.tri_subdomains == self.components[0])] = 1
        #self.tetra_subdomains[np.where(self.tetra_subdomains == self.components[0])] = 1

        for c in self.components[1:]:
            #n_clusters = np.sum(img_volumes[np.array(nd.sum(range(img_labels.shape[0]),img_labels,index=np.arange(10)*255+c-1),np.uint16)]>0)
            #n_clusters = np.sum(img_volumes[np.arange(n_clusters_max)*254+c-2]>0)
            clusters_labels = np.where(newlabels == c)[0]
            # print "Component", c, " : ",clusters_labels
            n_clusters = clusters_labels.size
            if n_clusters>0:
                tri_centers = np.mean(self.vertices[self.triangles[np.where(self.tri_subdomains == c)]],axis=1)
                tetra_centers = np.mean(self.vertices[self.tetrahedra[np.where(self.tetra_subdomains == c)]],axis=1)

                #self.displayMesh(np.array([c]))
                #self.superimposeMesh(mod_img,np.array([c]))
                #pgl.Viewer.frameGL.saveImage("CGAL_mesh_"+str(c)+".png")
                #raw_input()

                if n_clusters==1:
                    #print "  --> Component ",c," -> ",n_clusters," Cell : ",[c-2]
                    new.tri_subdomains[np.where(self.tri_subdomains == c)] = clusters_labels[0]
                    new.tetra_subdomains[np.where(self.tetra_subdomains == c)] = clusters_labels[0]
                else:
                    clusters = np.array(kmeans(tri_centers,n_clusters)[0],np.uint16)
                    img_points = np.array([img_graph.vertex_property('barycenter')[v] for v in clusters_labels])
                    # print clusters, '<->', img_points
                    #labels = img[clusters[:,0],clusters[:,1],clusters[:,2]]
                    #labels = clusters_labels[vq(img_points,clusters)[0]]
                    labels = clusters_labels[vq(clusters,img_points)[0]]

                    # print "  --> Component ",c," -> ",n_clusters," Cells : ",labels
                    tri_clusters = vq(tri_centers,clusters)[0]
                    tetra_clusters = vq(tetra_centers,clusters)[0]
                    new.tri_subdomains[np.where(self.tri_subdomains == c)] = labels[tri_clusters]
                    new.tetra_subdomains[np.where(self.tetra_subdomains == c)] = labels[tetra_clusters]


                #new.displayMesh(clusters_labels)
                #new.superimposeMesh(img,clusters_labels)
                #pgl.Viewer.frameGL.saveImage("CGAL_mesh_"+str(c)+"_relabeled.png")
                #raw_input()

        self.tri_subdomains = new.tri_subdomains
        self.tetra_subdomains = new.tetra_subdomains

        self.components = np.unique(self.tri_subdomains)
        print self.vertices.shape[0],"Vertices, ",self.triangles.shape[0],"Triangles, ",self.tetrahedra.shape[0],"Tetrahedra, ",self.components.shape[0]," Components"
        end_time = time()
        print "<-- Re-Indexing Components   [",end_time-start_time,"s]"


    def generateTopomesh(self):
        """
        """
        n_cells = self.components[1:].shape[0]
        print n_cells," Unique Cells"

        mesh_triangles = np.sort(self.triangles[np.where(self.tri_subdomains >= 1)])
        _,unique_triangles = np.unique(np.ascontiguousarray(mesh_triangles).view(np.dtype((np.void, mesh_triangles.dtype.itemsize * mesh_triangles.shape[1]))),return_index=True)
        mesh_unique_triangles = mesh_triangles[unique_triangles]
        n_triangles = mesh_unique_triangles.shape[0]
        print mesh_triangles.shape[0]," Triangles -> ",n_triangles," Unique Triangles"

        mesh_vertices = np.unique(mesh_triangles)
        n_vertices = mesh_vertices.shape[0]
        vertex_index = np.array(nd.sum(np.arange(n_vertices),mesh_vertices,index=np.arange(self.vertices.shape[0])),int)

        edge_index_list = np.array([[0, 1],[1, 2],[0, 2]])
        mesh_edges = np.sort(mesh_triangles[:,edge_index_list])
        mesh_edges = mesh_edges.reshape(mesh_edges.shape[0]*3,2)

        _,unique_edges = np.unique(np.ascontiguousarray(mesh_edges).view(np.dtype((np.void, mesh_edges.dtype.itemsize * mesh_edges.shape[1]))),return_index=True)
        mesh_unique_edges = mesh_edges[unique_edges]
        n_edges = mesh_unique_edges.shape[0]
        print mesh_edges.shape[0]," Edges -> ",n_edges," Unique Edges"

        print n_vertices," Unique Vertices"

        self.topo_mesh = Topomesh(3)

        self.topo_vertices = [self.topo_mesh.add_wisp(0) for v in xrange(n_vertices)]
        self.topo_edges = [self.topo_mesh.add_wisp(1) for e in xrange(n_edges)]
        self.topo_triangles = [self.topo_mesh.add_wisp(2) for t in xrange(n_triangles)]
        self.topo_cells = [self.topo_mesh.add_wisp(3) for c in self.components[1:]]

        start_time = time()
        print "--> Setting Vertex Positions"

        tri_centroids = np.array(np.average(self.vertices[self.triangles],axis=1),int)
        c0,c1,c2 = -np.mean(tri_centroids[:,0]), -np.mean(tri_centroids[:,1]), -np.mean(tri_centroids[:,2])
        self.vertex_positions = {}
        for v in xrange(n_vertices):
            self.vertex_positions[self.topo_vertices[v]] = self.vertices[mesh_vertices[v]]+[c0,c1,c2]
        end_time = time()
        print "<-- Setting Vertex Positions [",end_time-start_time,"s]"

        start_time = time()
        print "--> Linking Edges"
        for e in xrange(n_edges):
            self.topo_mesh.link(1,self.topo_edges[e],self.topo_vertices[vertex_index[mesh_unique_edges[e,0]]])
            self.topo_mesh.link(1,self.topo_edges[e],self.topo_vertices[vertex_index[mesh_unique_edges[e,1]]])
        end_time = time()
        print "<-- Linking Edges            [",end_time-start_time,"s]"

        start_time = time()
        print "--> Linking Triangles"
        for t in xrange(n_triangles):
            self.topo_mesh.link(2,self.topo_triangles[t],np.intersect1d(np.array(tuple(self.topo_mesh.regions(0,vertex_index[mesh_unique_triangles[t,0]]))),
                                                              np.array(tuple(self.topo_mesh.regions(0,vertex_index[mesh_unique_triangles[t,1]]))))[0])
            self.topo_mesh.link(2,self.topo_triangles[t],np.intersect1d(np.array(tuple(self.topo_mesh.regions(0,vertex_index[mesh_unique_triangles[t,0]]))),np.array(tuple(self.topo_mesh.regions(0,vertex_index[mesh_unique_triangles[t,2]]))))[0])
            self.topo_mesh.link(2,self.topo_triangles[t],np.intersect1d(np.array(tuple(self.topo_mesh.regions(0,vertex_index[mesh_unique_triangles[t,1]]))),np.array(tuple(self.topo_mesh.regions(0,vertex_index[mesh_unique_triangles[t,2]]))))[0])
        end_time = time()
        print "<-- Linking Triangles        [",end_time-start_time,"s]"

        start_time = time()
        cell_start_time = time()
        print "--> Linking Cells"
        for c in xrange(n_cells):
            cell_triangles = np.sort(self.triangles[np.where(self.tri_subdomains == self.components[1:][c])])
            _,unique_triangles = np.unique(np.ascontiguousarray(cell_triangles).view(np.dtype((np.void, cell_triangles.dtype.itemsize * cell_triangles.shape[1]))),return_index=True)
            cell_unique_triangles = cell_triangles[unique_triangles]
            for t in cell_unique_triangles:
                triangle_edges = np.zeros(3)
                triangle_edges[0] = np.intersect1d(np.array(tuple(self.topo_mesh.regions(0,vertex_index[t[0]]))),np.array(tuple(self.topo_mesh.regions(0,vertex_index[t[1]]))))[0]
                triangle_edges[1] = np.intersect1d(np.array(tuple(self.topo_mesh.regions(0,vertex_index[t[0]]))),np.array(tuple(self.topo_mesh.regions(0,vertex_index[t[2]]))))[0]
                triangle_edges[2] = np.intersect1d(np.array(tuple(self.topo_mesh.regions(0,vertex_index[t[1]]))),np.array(tuple(self.topo_mesh.regions(0,vertex_index[t[2]]))))[0]
                self.topo_mesh.link(3, self.topo_cells[c],np.intersect1d(np.intersect1d(np.array(tuple(self.topo_mesh.regions(1,triangle_edges[0]))),
                                                                              np.array(tuple(self.topo_mesh.regions(1,triangle_edges[1])))),
                                                                              np.array(tuple(self.topo_mesh.regions(1,triangle_edges[2]))))[0])
            
            if (c%100 == 0):
                cell_end_time = time()
                print"    <-- Linking Cell",c,"  [",cell_end_time-cell_start_time,"s]"
                cell_start_time = time()
        end_time = time()
        print "<-- Linking Cells       [",end_time-start_time,"s]"

        return self.topo_mesh

    def generatePropertyTopomesh(self):
        """
        """
        n_cells = self.components[1:].shape[0]
        print n_cells," Unique Cells"

        mesh_triangles = np.sort(self.triangles[np.where(self.tri_subdomains >= 1)])
        _,unique_triangles = np.unique(np.ascontiguousarray(mesh_triangles).view(np.dtype((np.void, mesh_triangles.dtype.itemsize * mesh_triangles.shape[1]))),return_index=True)
        mesh_unique_triangles = mesh_triangles[unique_triangles]
        n_triangles = mesh_unique_triangles.shape[0]
        # print mesh_triangles.shape[0]," Triangles -> ",n_triangles," Unique Triangles"

        mesh_vertices = np.unique(mesh_triangles)
        n_vertices = mesh_vertices.shape[0]
        vertex_index = np.array(nd.sum(np.arange(n_vertices),mesh_vertices,index=np.arange(self.vertices.shape[0])),int)

        edge_index_list = np.array([[0, 1],[1, 2],[0, 2]])
        mesh_edges = np.sort(mesh_triangles[:,edge_index_list])
        mesh_edges = mesh_edges.reshape(mesh_edges.shape[0]*3,2)

        _,unique_edges = np.unique(np.ascontiguousarray(mesh_edges).view(np.dtype((np.void, mesh_edges.dtype.itemsize * mesh_edges.shape[1]))),return_index=True)
        mesh_unique_edges = mesh_edges[unique_edges]
        n_edges = mesh_unique_edges.shape[0]
        # print mesh_edges.shape[0]," Edges -> ",n_edges," Unique Edges"

        # print n_vertices," Unique Vertices"

        self.topo_mesh = PropertyTopomesh(3)

        self.topo_vertices = [self.topo_mesh.add_wisp(0) for v in xrange(n_vertices)]
        self.topo_edges = [self.topo_mesh.add_wisp(1) for e in xrange(n_edges)]
        self.topo_triangles = [self.topo_mesh.add_wisp(2) for t in xrange(n_triangles)]
        self.topo_cells = [self.topo_mesh.add_wisp(3,c) for c in self.components[1:]]

        start_time = time()
        print "--> Setting Vertex Positions"

        tri_centroids = np.array(np.average(self.vertices[self.triangles],axis=1),int)
        c0,c1,c2 = -np.mean(tri_centroids[:,0]), -np.mean(tri_centroids[:,1]), -np.mean(tri_centroids[:,2])
        self.vertex_positions = {}
        for v in xrange(n_vertices):
            self.vertex_positions[self.topo_vertices[v]] = self.vertices[mesh_vertices[v]]
            # self.vertex_positions[self.topo_vertices[v]] = self.vertices[mesh_vertices[v]]+[c0,c1,c2]
        end_time = time()
        print "<-- Setting Vertex Positions [",end_time-start_time,"s]"

        start_time = time()
        print "--> Linking Edges"
        for e in xrange(n_edges):
            eid = self.topo_edges[e]
            pid = self.topo_vertices[vertex_index[mesh_unique_edges[e,0]]]
            self.topo_mesh.link(1,eid,pid)
            pid = self.topo_vertices[vertex_index[mesh_unique_edges[e,1]]]
            self.topo_mesh.link(1,eid,pid)
        end_time = time()
        print "<-- Linking Edges            [",end_time-start_time,"s]"

        start_time = time()
        print "--> Linking Triangles"
        for t in xrange(n_triangles):
            fid = self.topo_triangles[t]
            
            eid = np.intersect1d(np.array(tuple(self.topo_mesh.regions(0,vertex_index[mesh_unique_triangles[t,0]]))),np.array(tuple(self.topo_mesh.regions(0,vertex_index[mesh_unique_triangles[t,1]]))))[0]
            self.topo_mesh.link(2,fid,eid)

            eid = np.intersect1d(np.array(tuple(self.topo_mesh.regions(0,vertex_index[mesh_unique_triangles[t,0]]))),np.array(tuple(self.topo_mesh.regions(0,vertex_index[mesh_unique_triangles[t,2]]))))[0]
            self.topo_mesh.link(2,fid,eid)
            
            eid = np.intersect1d(np.array(tuple(self.topo_mesh.regions(0,vertex_index[mesh_unique_triangles[t,1]]))),np.array(tuple(self.topo_mesh.regions(0,vertex_index[mesh_unique_triangles[t,2]]))))[0]
            self.topo_mesh.link(2,fid,eid)
        end_time = time()
        print "<-- Linking Triangles        [",end_time-start_time,"s]"

        start_time = time()
        # cell_start_time = time()
        print "--> Linking Cells"
        for c in xrange(n_cells):
            cid = self.topo_cells[c]
            cell_triangles = np.sort(self.triangles[np.where(self.tri_subdomains == self.components[1:][c])])
            _,unique_triangles = np.unique(np.ascontiguousarray(cell_triangles).view(np.dtype((np.void, cell_triangles.dtype.itemsize * cell_triangles.shape[1]))),return_index=True)
            cell_unique_triangles = cell_triangles[unique_triangles]
            for t in cell_unique_triangles:
                triangle_edges = np.zeros(3)
                triangle_edges[0] = np.intersect1d(np.array(tuple(self.topo_mesh.regions(0,vertex_index[t[0]]))),np.array(tuple(self.topo_mesh.regions(0,vertex_index[t[1]]))))[0]
                triangle_edges[1] = np.intersect1d(np.array(tuple(self.topo_mesh.regions(0,vertex_index[t[0]]))),np.array(tuple(self.topo_mesh.regions(0,vertex_index[t[2]]))))[0]
                triangle_edges[2] = np.intersect1d(np.array(tuple(self.topo_mesh.regions(0,vertex_index[t[1]]))),np.array(tuple(self.topo_mesh.regions(0,vertex_index[t[2]]))))[0]
                fid = np.intersect1d(np.intersect1d(np.array(tuple(self.topo_mesh.regions(1,triangle_edges[0]))),
                                                    np.array(tuple(self.topo_mesh.regions(1,triangle_edges[1])))),
                                                    np.array(tuple(self.topo_mesh.regions(1,triangle_edges[2])))) [0]
                self.topo_mesh.link(3,cid,fid)
            # if (c%100 == 0):
            #     cell_end_time = time()
            #     print"    <-- Linking Cell",c,"  [",cell_end_time-cell_start_time,"s]"
            #     cell_start_time = time()
        end_time = time()
        print "<-- Linking Cells       [",end_time-start_time,"s]"

        start_time = time()
        print "--> Cleaning Triangles"
        triangles_to_remove = []
        for t in self.topo_mesh.wisps(2):
            if len(list(self.topo_mesh.regions(2,t))) == 0:
                triangles_to_remove.append(t)
        for t in triangles_to_remove:
            self.topo_mesh.remove_wisp(2,t)
        self.topo_triangles = list(np.delete(self.topo_triangles,triangles_to_remove))

        edges_to_remove = []
        for e in self.topo_mesh.wisps(1):
            if len(list(self.topo_mesh.regions(1,e))) == 0:
                edges_to_remove.append(e)
        for e in edges_to_remove:
            self.topo_mesh.remove_wisp(1,e)
        self.topo_edges = list(np.delete(self.topo_edges,edges_to_remove))

        vertices_to_remove = []
        for v in self.topo_mesh.wisps(0):
            if len(list(self.topo_mesh.regions(0,v))) == 0:
                vertices_to_remove.append(v)
        for v in vertices_to_remove:
            self.topo_mesh.remove_wisp(0,v)
            del self.vertex_positions[v]
        self.topo_vertices = list(np.delete(self.topo_vertices,vertices_to_remove))
        end_time = time()
        print "<-- Cleaning Triangles  [",end_time-start_time,"s]"


        start_time = time()
        print "--> Computing Interfaces"

        for cid in self.topo_mesh.wisps(3):
            for n_cid in self.topo_mesh.border_neighbors(3,cid):
                if (n_cid<cid) and (not (n_cid,cid) in self.topo_mesh._interface[3].values()):
                        iid = self.topo_mesh._interface[3].add((n_cid,cid),None)
            # if (cid%100 == 0):
            #     print"    <-- Interface Cell",cid

        end_time = time()
        print "<-- Computing Interfaces[",end_time-start_time,"s]"


        return self.topo_mesh

    def generateTetrahedraPropertyTopomesh(self):

        tetra_triangle_edge_list  = np.array([[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]])
        tetra_triangle_list  = np.array([[0,1,2],[0,1,3],[0,2,3],[1,2,3]])
        triangle_edge_list  = np.array([[1, 2],[0, 2],[0, 1]])

        triangles = np.sort(np.concatenate(self.tetrahedra[:,tetra_triangle_list],axis=0))
        unique_triangles = array_unique(triangles)
        tetrahedra_triangles = np.sort(np.concatenate(self.tetrahedra[:,tetra_triangle_list],axis=0))
        tetrahedra_triangle_matching = vq(tetrahedra_triangles,unique_triangles)[0]
        #tetrahedra_triangle_matching = vq(unique_triangles,tetrahedra_triangles)[0]

        edges = np.sort(np.concatenate(unique_triangles[:,triangle_edge_list],axis=0))
        unique_edges = array_unique(edges)
        triangle_edges = np.sort(np.concatenate(unique_triangles[:,triangle_edge_list],axis=0))
        triangle_edge_matching = vq(triangle_edges,unique_edges)[0]
        #triangle_edge_matching = vq(unique_edges,triangle_edges)[0]

        self.topo_mesh = PropertyTopomesh(3)
        positions = {}
        for v in np.unique(self.tetrahedra):
            self.topo_mesh.add_wisp(0,v)
            positions[v] = self.vertices[v]
        for e in unique_edges:
            eid = self.topo_mesh.add_wisp(1)
            for pid in e:
                self.topo_mesh.link(1,eid,pid)
        for t in unique_triangles:
            fid = self.topo_mesh.add_wisp(2)
            for eid in triangle_edge_matching[3*fid:3*fid+3]:
                self.topo_mesh.link(2,fid,eid)
        for t in self.tetrahedra:
            cid = self.topo_mesh.add_wisp(3)
            for fid in tetrahedra_triangle_matching[4*cid:4*cid+4]:
                self.topo_mesh.link(3,cid,fid)

        self.topo_mesh.update_wisp_property('barycenter',0,positions)        

